# 哈夫曼树编码-译码

**[问题描述]**

打开一篇英文文章，统计该文章中每个字符出现的次数，然后以它们作为权值，对每一个字符进行编码，编码完成后再对其编码进行译码。 利用哈夫曼编码进行信息通信可以大大提高信道利用率，缩短信息传输时间，降低传输成本。但是，这要求在发送端通过一个编码系统对待传数据预先编码，在接收端将传来的数据进行译码（复原）。对于双工信道（即可以双向传输信息的信道），每端都需要一个完整的编/译码系统。试为这样的信息收发站写一个哈夫曼编/译码系统。

**[基本要求]**

一个完整的系统应具有以下功能：

1. I：初始化（Initialization）。从终端读入字符集大小n，以及n个字符和n个权值，建立哈夫曼树，并将它存于文件**hfmTree**中。
2. E：编码（Encoding）。利用已建好的哈夫曼树（如不在内存，则从文件**htmTree**中读入），对文件**ToBeTran**中的正文进行编码，然后将结果存入文件**CodeFile**中。
3. D：译码（Decoding）。利用已建好的哈夫曼树将文件**CodeFile**中的代码进行译码，结果存入文件**TextFile**中。
4. P：打印代码文件（Print）。将文件**CodeFile**以紧凑格式显示在终端上，每行50个代码。同时将此字符形式的编码写入文件**CodePrint**中。
5. T：印哈夫曼树（TreePrinting）。将已在内存中的哈夫曼树以直观的方式（树或凹入表形式）显示在终端上，同时将此字符形式的哈夫曼树写入文件**TreePrint**中。

**[测试数据]**

新建一个.txt文件，用来存放待处理的数据，这些数据为ASCII码值的集合，而且每种字符的数量并不能相同。本实验拟设其中的数据为abbcccdddd.

**[实现提示]**

1. 文件CodeFile的基类型可以设为子界型bit= 0..1。
2. 用户界面可以设计为“菜单”方式：显示上述功能符号，再加上“Q”，表示运行Quit。请用户键入一个先把功能符，些功能执行完毕后再经菜单，直至某次用户先把了“E”为止。
3. 在程序的一次执行过程中，第一次执行I、D或C命令之后，哈夫曼树已经在内存了，不必再读入。每次执行中不一定执行I命令，因为文件hfmTree可能早已建好。

## 初始化

哈夫曼树的创建，使用优先队列，顺序遍历，将每个树节点存到对应的位置，数值小的在前。构建树，先将小权值相加，再返回队列。不断重复最终生成哈夫曼树。

文件IO，将每一个字符加权值输出到文件hfmtree。
